classdef Particle

    properties
        weight = 0;
        pose = [0,0,0];
        lidar;
    end
  
    methods (Static)
        function particle = newParticle(lidar)
            arguments
                lidar Lidar
            end
            particle.lidar = lidar;
        end
    end
    
    methods 
        function result = isValid(particle, map)
            arguments
                particle Particle
                map occupancyMap
            end
            
            x = particle.pose(1);
            y = particle.pose(2);
            
            if (map.XWorldLimits(1) < x && ...
                map.XWorldLimits(2) > x && ...
                map.YWorldLimits(1) < y && ...
                map.YWorldLimits(2) > y )
                
                result = true;
                return
            end
            
            result = false;
        end
        
        function [sensorPose, scanAngles] = getLidarPoseAndScanAngles(particle)
            % Cada particula es una 'instancia' de un robot, por lo que las
            % particulas poseen un lidar tambi√©n. Al tomar mediciones, hay 
            % que transformarlas a la terna de la particula, por lo que
            % necesitamos estos datos del sensor
            theta = particle.pose(3);
            offsetVec = [cos(theta) -sin(theta);
                         sin(theta)  cos(theta)]*particle.lidar.sensorOffset';

            sensorLoc = [particles(k).pose_x, particles(k).pose_y] + offsetVec';
            sensorPose = [sensorLoc, theta + particle.lidar.sensorAngleOffset];
            scanAngles = particle.lidar.scanAngles;
        end
    end
end

